"""
Heat Recovery Unit Model
Recovers waste heat from microturbine exhaust
"""

from typing import Dict
from ..base import TechnologyBase


class HeatRecovery(TechnologyBase):
    """
    Heat Recovery Unit (Heat Exchanger)

    Recovers heat from high-temperature microturbine exhaust

    Input:
    - Hot exhaust gas from microturbine

    Output:
    - Useful thermal energy (hot water/steam)
    - Cooled exhaust gas
    """

    def _define_specs(self) -> Dict:
        """
        Define heat recovery unit specifications

        Based on: Commercial heat recovery systems
        """
        return {
            'name': 'Heat_Recovery_Unit',
            'recovery_efficiency': 0.75,     # 75% heat recovery efficiency
            'min_exhaust_temp': 150,         # °C (minimum temp for recovery)
            'output_temperature': 90,        # °C (hot water output)
            'exhaust_exit_temp': 120,        # °C (cooled exhaust exit temp)
            'pressure_drop': 50,             # Pa (pressure drop in heat exchanger)
            'capex': 150,                    # $/kW thermal capacity
            'opex': 0.005,                   # $/kWh heat recovered
            'lifetime': 25,                  # years
            'effectiveness': 0.75,           # Heat exchanger effectiveness
            'fouling_factor': 0.95           # Performance degradation due to fouling
        }

    def calculate_heat_recovery_from_gt(self, p_gt: float, eta_gt: float) -> Dict:
        """
        Calculate heat recovery using exact formula for microturbine exhaust

        Formula:
            p_whb(t) = p_gt(t) × η_whb × ((1-η_gt)/η_gt)

        Where:
            p_whb(t): Output power of the WHB (heat recovery output in kWh)
            p_gt(t): Power generated by the gas turbine (kWh)
            η_whb: Working efficiency of the WHB (recovery efficiency)
            η_gt: Power generation efficiency of GT

        Args:
            p_gt: Power generated by gas turbine (kWh)
            eta_gt: Gas turbine electrical efficiency (η_gt)

        Returns:
            Heat recovery details
        """
        # Get WHB efficiency
        eta_whb = self.specs['recovery_efficiency']

        # Calculate heat recovery using exact formula
        # p_whb(t) = p_gt(t) × η_whb × ((1-η_gt)/η_gt)
        p_whb = p_gt * eta_whb * ((1 - eta_gt) / eta_gt)

        return {
            'p_gt_kwh': p_gt,
            'eta_gt': eta_gt,
            'eta_whb': eta_whb,
            'p_whb_kwh': p_whb,
            'recovered_heat_kwh': p_whb,
            'formula': 'p_whb(t) = p_gt(t) × η_whb × ((1-η_gt)/η_gt)'
        }

    def calculate_heat_recovery(self, exhaust_heat_kwh: float,
                                exhaust_temp_c: float,
                                exhaust_flow_kg_h: float = None) -> Dict:
        """
        Calculate recoverable heat from exhaust (alternative method)

        Note: For microturbine applications, prefer using calculate_heat_recovery_from_gt()
        which implements the exact formula: p_whb(t) = p_gt(t) × η_whb × ((1-η_gt)/η_gt)

        Args:
            exhaust_heat_kwh: Total heat in exhaust (kWh)
            exhaust_temp_c: Exhaust gas temperature (°C)
            exhaust_flow_kg_h: Exhaust flow rate (kg/h) - optional

        Returns:
            Heat recovery details
        """
        # Check if temperature is sufficient
        if exhaust_temp_c < self.specs['min_exhaust_temp']:
            return {
                'exhaust_heat_kwh': exhaust_heat_kwh,
                'exhaust_temp_c': exhaust_temp_c,
                'recoverable_heat_kwh': 0,
                'recovered_heat_kwh': 0,
                'recovery_efficiency': 0,
                'sufficient_temperature': False,
                'reason': f"Exhaust temp {exhaust_temp_c}°C < minimum {self.specs['min_exhaust_temp']}°C"
            }

        # Theoretical maximum recoverable heat
        # Limited by exit temperature and effectiveness
        temp_ratio = (exhaust_temp_c - self.specs['exhaust_exit_temp']) / \
                     (exhaust_temp_c - self.specs['output_temperature'])
        temp_ratio = min(1.0, max(0.0, temp_ratio))

        # Recoverable heat considering temperature limits
        recoverable_heat = exhaust_heat_kwh * temp_ratio

        # Actual recovered heat (accounting for efficiency and fouling)
        recovered_heat = recoverable_heat * \
                        self.specs['recovery_efficiency'] * \
                        self.specs['fouling_factor']

        # Recovery efficiency
        recovery_eff = recovered_heat / exhaust_heat_kwh if exhaust_heat_kwh > 0 else 0

        return {
            'exhaust_heat_kwh': exhaust_heat_kwh,
            'exhaust_temp_c': exhaust_temp_c,
            'recoverable_heat_kwh': recoverable_heat,
            'recovered_heat_kwh': recovered_heat,
            'output_temperature_c': self.specs['output_temperature'],
            'exhaust_exit_temp_c': self.specs['exhaust_exit_temp'],
            'recovery_efficiency': recovery_eff,
            'heat_exchanger_effectiveness': self.specs['effectiveness'],
            'fouling_factor': self.specs['fouling_factor'],
            'sufficient_temperature': True,
            'heat_lost_kwh': exhaust_heat_kwh - recovered_heat
        }

    def calculate_capacity_requirement(self, peak_exhaust_heat_kw: float) -> Dict:
        """
        Calculate heat recovery unit sizing

        Args:
            peak_exhaust_heat_kw: Peak exhaust heat rate (kW)

        Returns:
            Sizing information
        """
        # Design capacity (with 10% safety margin)
        design_capacity_kw = peak_exhaust_heat_kw * 1.1

        # Recovered capacity
        recovered_capacity_kw = design_capacity_kw * \
                               self.specs['recovery_efficiency'] * \
                               self.specs['fouling_factor']

        # CAPEX
        total_capex = design_capacity_kw * self.specs['capex']

        return {
            'peak_exhaust_heat_kw': peak_exhaust_heat_kw,
            'design_capacity_kw': design_capacity_kw,
            'recovered_capacity_kw': recovered_capacity_kw,
            'recovery_efficiency': self.specs['recovery_efficiency'],
            'total_capex': total_capex,
            'capex_per_kw': self.specs['capex']
        }

    def calculate_annual_heat_recovery(self, annual_exhaust_heat_kwh: float,
                                       average_exhaust_temp_c: float) -> Dict:
        """
        Calculate annual heat recovery performance

        Args:
            annual_exhaust_heat_kwh: Annual exhaust heat available (kWh)
            average_exhaust_temp_c: Average exhaust temperature (°C)

        Returns:
            Annual performance metrics
        """
        # Heat recovery
        recovery = self.calculate_heat_recovery(
            annual_exhaust_heat_kwh,
            average_exhaust_temp_c
        )

        if not recovery['sufficient_temperature']:
            return recovery

        # Operating cost
        annual_opex = recovery['recovered_heat_kwh'] * self.specs['opex']

        # Value of recovered heat (if sold or used)
        # Assume equivalent to natural gas heat value
        heat_value_per_kwh = 0.05  # $/kWh (typical)
        annual_heat_value = recovery['recovered_heat_kwh'] * heat_value_per_kwh

        return {
            'annual_exhaust_heat_kwh': annual_exhaust_heat_kwh,
            'annual_recovered_heat_kwh': recovery['recovered_heat_kwh'],
            'recovery_efficiency': recovery['recovery_efficiency'],
            'annual_opex': annual_opex,
            'annual_heat_value': annual_heat_value,
            'net_annual_benefit': annual_heat_value - annual_opex,
            'average_exhaust_temp_c': average_exhaust_temp_c
        }

    def calculate_economics(self, annual_exhaust_heat_kwh: float,
                           average_exhaust_temp_c: float,
                           heat_price_per_kwh: float = 0.05,
                           peak_capacity_kw: float = 100) -> Dict:
        """
        Calculate complete economics for heat recovery

        Args:
            annual_exhaust_heat_kwh: Annual exhaust heat (kWh)
            average_exhaust_temp_c: Average exhaust temperature (°C)
            heat_price_per_kwh: Value of recovered heat ($/kWh)
            peak_capacity_kw: Peak capacity (kW)

        Returns:
            Economic analysis
        """
        # Heat recovery
        recovery = self.calculate_heat_recovery(
            annual_exhaust_heat_kwh,
            average_exhaust_temp_c
        )

        if not recovery['sufficient_temperature']:
            return {
                'feasible': False,
                'reason': recovery['reason']
            }

        # CAPEX
        sizing = self.calculate_capacity_requirement(peak_capacity_kw)
        total_capex = sizing['total_capex']
        annual_capex = total_capex / self.specs['lifetime']

        # OPEX
        annual_opex = recovery['recovered_heat_kwh'] * self.specs['opex']

        # Revenue from heat
        annual_revenue = recovery['recovered_heat_kwh'] * heat_price_per_kwh

        # Net benefit
        net_annual_benefit = annual_revenue - annual_opex - annual_capex

        # NPV
        npv = self.calculate_npv(
            capex=total_capex,
            annual_revenue=annual_revenue,
            annual_opex=annual_opex,
            discount_rate=0.08
        )

        # Payback period
        payback = self.calculate_payback_period(
            total_capex,
            annual_revenue,
            annual_opex
        )

        return {
            'feasible': True,
            'annual_recovered_heat_kwh': recovery['recovered_heat_kwh'],
            'recovery_efficiency': recovery['recovery_efficiency'],
            'capex': total_capex,
            'annual_capex': annual_capex,
            'annual_opex': annual_opex,
            'annual_revenue': annual_revenue,
            'net_annual_benefit': net_annual_benefit,
            'npv': npv,
            'payback_period_years': payback,
            'heat_price_per_kwh': heat_price_per_kwh
        }

    def calculate_combined_microturbine_heat_recovery(self,
                                                      microturbine_outputs: Dict,
                                                      heat_demand_kwh: float = None) -> Dict:
        """
        Calculate combined microturbine + heat recovery system using exact formula

        Uses formula: p_whb(t) = p_gt(t) × η_whb × ((1-η_gt)/η_gt)

        Args:
            microturbine_outputs: Output dictionary from GasMicroturbine.calculate_outputs()
                                 Must contain 'p_gt' and 'eta_gt' keys
            heat_demand_kwh: Heat demand to meet (optional)

        Returns:
            Combined system outputs
        """
        # Heat recovery from microturbine using exact formula
        if 'p_gt' in microturbine_outputs and 'eta_gt' in microturbine_outputs:
            # Use exact formula
            recovery = self.calculate_heat_recovery_from_gt(
                microturbine_outputs['p_gt'],
                microturbine_outputs['eta_gt']
            )
        else:
            # Fallback to temperature-based method for backward compatibility
            recovery = self.calculate_heat_recovery(
                microturbine_outputs['exhaust_heat_kwh'],
                microturbine_outputs['exhaust_temperature_c'],
                microturbine_outputs.get('exhaust_flow_kg_h')
            )

        # Total system outputs
        total_electricity = microturbine_outputs['electricity_kwh']
        total_useful_heat = recovery['recovered_heat_kwh']

        # Combined efficiency
        fuel_input = microturbine_outputs['fuel_input_kwh']
        combined_efficiency = (total_electricity + total_useful_heat) / fuel_input if fuel_input > 0 else 0

        # Heat utilization
        if heat_demand_kwh is not None:
            heat_utilization = min(1.0, heat_demand_kwh / total_useful_heat) if total_useful_heat > 0 else 0
            excess_heat = max(0, total_useful_heat - heat_demand_kwh)
        else:
            heat_utilization = 1.0
            excess_heat = 0

        return {
            'electricity_kwh': total_electricity,
            'useful_heat_kwh': total_useful_heat,
            'heat_utilized_kwh': total_useful_heat * heat_utilization,
            'excess_heat_kwh': excess_heat,
            'fuel_input_kwh': fuel_input,
            'combined_efficiency': combined_efficiency,
            'electrical_efficiency': microturbine_outputs['electrical_efficiency'],
            'heat_recovery_efficiency': recovery['recovery_efficiency'],
            'co2_emissions_kg': microturbine_outputs['co2_emissions_kg'],
            'co2_for_ccu_kg': microturbine_outputs['co2_emissions_kg']
        }
